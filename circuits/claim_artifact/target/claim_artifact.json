{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13971326946962524695,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"treasure_seed","type":{"kind":"field"},"visibility":"public"},{"name":"artifact_id","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"1272965546042368918":{"error_kind":"string","string":"Artifact ID mismatch"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6186021530770169760":{"error_kind":"string","string":"Artifact ID out of range"},"6633934283979419638":{"error_kind":"string","string":"Invalid artifact ID"},"9989860789624223510":{"error_kind":"string","string":"Cell is not a treasure"},"12212259287858967958":{"error_kind":"string","string":"Y coordinate out of bounds"},"13827481945052318821":{"error_kind":"string","string":"Position commitment mismatch"},"14171121810365326921":{"error_kind":"string","string":"X coordinate out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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h3jVDkrwypz3qhnvVTP+O0CN/w5Q471qxnvVjPeqGe9VM96rZrxXzXivmjnPbuffu3mvmvFeNeO9asZ/B6g1nt28V814r5rxXjXjvWrGe9WM96oZ71WzzrO78+/dvFfNeK+a8V41478D1DrPbt6rZrxXzXivmvFeNeO9asZ71Yz3qtnKs3vl37t5r5rxXjXjvWrOfweoL4UvIXyJypdQvoTxJZwv0fgSnS/Bs7ssfInClxC+ROVL8OwuPLt5r5rzXjXnvWrOe9Wc96o571Vz3qvmwrN7iFftoITxJZwv0fgSPLuFZzfvVXPeq+a8V815r5rzXjXnvWrOe9W88uyunS/BK3Peq+a8V8357wB15dnNe9Wc96o571Vz3qvmvFfNea+a8141N57dxr938141571qznvVnP8OUOe9as7nqjmfq+b8d4A6/x2gznvV3Hl2O89u59nt/Hs371VzPlfN+e8Adf47QL3x790jvGoqdimh0l6X+Aq718sqEfHnJf5epQ+tsodW+UOrvsKUVa+ranm9qj+06jaeRZ9Wubxa9RXD1dGq8tAqeWhVfWiVPrTKHlrlD61qD63qh6vaaxx+xdtTn9CrS3216it2naNVt7GhulxXaX+9Sh5aVR9apfeu2v7y46/v3r9/969/vP/40w+/v/v44bdPS5dP/3P7H5nKUsqX25Wl2tOW127tj8vl42tFnl/66Xk7e/v1229f63VzX1/c/vY/LN15e7nc/tk58+X25dtv36+n39pe3l7Y29dvvn0X/3Jt15cf7e1/SLrz9heud/OXt7dvv327fLT99Q/HB95+fYH7v7a//c8Pv7774cf3bz8x+dN//OPDTxdib3/9/X9/ufyXC/V/+fXjT29//uPXt582gWf8/wTxunxXbbvtduv/Aw==","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"use std::hash::pedersen_hash;\nuse poseidon::poseidon::bn254::hash_3;\nuse poseidon::poseidon::bn254::hash_4;\n\n/// Threshold for treasure cells (same as contract: hash % 256 < 20 means ~7.8% of cells)\nglobal TREASURE_THRESHOLD: u32 = 20;\n\n/// Domain separator for artifact ID derivation (must match contract!)\n/// \"artifact\" as ASCII: 0x617274696661637400\nglobal ARTIFACT_DOMAIN_SEP: Field = 0x617274696661637400;\n\n/// Claim Artifact Circuit (Procedural Treasures with Poseidon)\n/// Proves a player is at a valid procedurally-generated treasure cell.\n///\n/// Private inputs: x, y, salt\n/// Public inputs: commitment, treasure_seed, artifact_id\n///\n/// Proves:\n///   1. commitment = pedersen(x, y, salt)  -- player knows their position\n///   2. poseidon(x, y, treasure_seed) % 256 < THRESHOLD -- cell is a treasure\n///   3. artifact_id matches poseidon(x, y, treasure_seed, ARTIFACT_DOMAIN_SEP) derivation\nfn main(\n    // Private inputs\n    x: Field,\n    y: Field,\n    salt: Field,\n    // Public inputs\n    commitment: pub Field,\n    treasure_seed: pub Field,\n    artifact_id: pub Field,\n) {\n    // Validate coordinates are in bounds (0-15)\n    let x_u8 = x as u8;\n    let y_u8 = y as u8;\n    assert(x_u8 < 16, \"X coordinate out of bounds\");\n    assert(y_u8 < 16, \"Y coordinate out of bounds\");\n\n    // 1. Verify position commitment (still using Pedersen for commitments)\n    let computed_commitment = pedersen_hash([x, y, salt]);\n    assert(computed_commitment == commitment, \"Position commitment mismatch\");\n\n    // 2. Verify cell is a procedural treasure using POSEIDON\n    //    poseidon(x, y, treasure_seed) % 256 < THRESHOLD\n    let cell_hash = hash_3([x, y, treasure_seed]);\n    let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n    // Use last byte for modulo 256\n    let hash_mod = cell_hash_bytes[31] as u32;\n    assert(hash_mod < TREASURE_THRESHOLD, \"Cell is not a treasure\");\n\n    // 3. Verify artifact_id matches derivation using POSEIDON\n    //    artifact_id = (poseidon(x, y, treasure_seed, ARTIFACT_DOMAIN_SEP) % 8) + 1\n    let artifact_hash = hash_4([x, y, treasure_seed, ARTIFACT_DOMAIN_SEP]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    let derived_id = ((artifact_bytes[31] as u32) % 8) + 1;\n    assert(artifact_id as u32 == derived_id, \"Artifact ID mismatch\");\n\n    // Validate artifact_id is in valid range\n    let aid = artifact_id as u32;\n    assert(aid >= 1, \"Invalid artifact ID\");\n    assert(aid <= 8, \"Artifact ID out of range\");\n}\n\n/// Helper: compute a position commitment (still uses Pedersen)\nfn compute_commitment(x: Field, y: Field, salt: Field) -> Field {\n    pedersen_hash([x, y, salt])\n}\n\n/// Helper: check if a cell is a treasure using Poseidon\nfn is_treasure(x: Field, y: Field, treasure_seed: Field) -> bool {\n    let cell_hash = hash_3([x, y, treasure_seed]);\n    let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n    let hash_mod = cell_hash_bytes[31] as u32;\n    hash_mod < TREASURE_THRESHOLD\n}\n\n/// Helper: compute artifact ID at a treasure cell using Poseidon\nfn get_artifact_id(x: Field, y: Field, treasure_seed: Field) -> u32 {\n    let artifact_hash = hash_4([x, y, treasure_seed, ARTIFACT_DOMAIN_SEP]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    ((artifact_bytes[31] as u32) % 8) + 1\n}\n\n// ============================================================\n// Test helpers (unconstrained for efficiency)\n// ============================================================\n\n/// Find a treasure cell for testing using Poseidon\nunconstrained fn find_treasure_cell(treasure_seed: Field) -> (Field, Field) {\n    let mut result_x: Field = 0;\n    let mut result_y: Field = 0;\n    let mut found = false;\n    \n    for y in 0..16 {\n        for x in 0..16 {\n            if !found {\n                let cell_hash = poseidon::poseidon::bn254::hash_3([x as Field, y as Field, treasure_seed]);\n                let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n                let hash_mod = cell_hash_bytes[31] as u32;\n                if hash_mod < TREASURE_THRESHOLD {\n                    result_x = x as Field;\n                    result_y = y as Field;\n                    found = true;\n                }\n            }\n        }\n    }\n    (result_x, result_y)\n}\n\n/// Find a non-treasure cell for testing\nunconstrained fn find_non_treasure_cell(treasure_seed: Field) -> (Field, Field) {\n    let mut result_x: Field = 0;\n    let mut result_y: Field = 0;\n    let mut found = false;\n    \n    for y in 0..16 {\n        for x in 0..16 {\n            if !found {\n                let cell_hash = poseidon::poseidon::bn254::hash_3([x as Field, y as Field, treasure_seed]);\n                let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n                let hash_mod = cell_hash_bytes[31] as u32;\n                if hash_mod >= TREASURE_THRESHOLD {\n                    result_x = x as Field;\n                    result_y = y as Field;\n                    found = true;\n                }\n            }\n        }\n    }\n    (result_x, result_y)\n}\n\n/// Get artifact ID (unconstrained version)\nunconstrained fn get_artifact_id_unconstrained(x: Field, y: Field, treasure_seed: Field) -> u32 {\n    let artifact_hash = poseidon::poseidon::bn254::hash_4([x, y, treasure_seed, ARTIFACT_DOMAIN_SEP]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    ((artifact_bytes[31] as u32) % 8) + 1\n}\n\n// ============================================================\n// Tests\n// ============================================================\n\n#[test]\nfn test_valid_claim() {\n    let treasure_seed: Field = 12345;\n    \n    // Safety: test-only unconstrained helper to find treasure\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n\n    let commitment = compute_commitment(x, y, salt);\n    // Safety: test-only unconstrained helper\n    let artifact_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) } as Field;\n\n    main(x, y, salt, commitment, treasure_seed, artifact_id);\n}\n\n#[test]\nfn test_different_seeds_different_treasures() {\n    let seed1: Field = 11111;\n    let seed2: Field = 22222;\n    \n    // Safety: test-only unconstrained helpers\n    let (x1, y1) = unsafe { find_treasure_cell(seed1) };\n    // Safety: test-only unconstrained helpers\n    let (x2, y2) = unsafe { find_treasure_cell(seed2) };\n    \n    // Just verify both are valid treasures\n    assert(is_treasure(x1, y1, seed1));\n    assert(is_treasure(x2, y2, seed2));\n}\n\n#[test(should_fail_with = \"Cell is not a treasure\")]\nfn test_non_treasure_cell_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    \n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_non_treasure_cell(treasure_seed) };\n\n    let commitment = compute_commitment(x, y, salt);\n    // Try to claim artifact 1 at non-treasure cell\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let treasure_seed: Field = 12345;\n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n    // Safety: test-only unconstrained helper\n    let artifact_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) } as Field;\n\n    // Wrong commitment - should fail\n    main(x, y, salt, 0, treasure_seed, artifact_id);\n}\n\n#[test(should_fail)]\nfn test_wrong_artifact_id_fails() {\n    let treasure_seed: Field = 12345;\n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n\n    let commitment = compute_commitment(x, y, salt);\n    // Safety: test-only unconstrained helper\n    let correct_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) };\n    // Pick wrong ID\n    let wrong_id = if correct_id == 1 { 2 } else { 1 };\n\n    main(x, y, salt, commitment, treasure_seed, wrong_id as Field);\n}\n\n#[test(should_fail_with = \"X coordinate out of bounds\")]\nfn test_x_out_of_bounds_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    let x: Field = 16; // Out of bounds\n    let y: Field = 5;\n\n    let commitment = compute_commitment(x, y, salt);\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n#[test(should_fail_with = \"Y coordinate out of bounds\")]\nfn test_y_out_of_bounds_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    let x: Field = 5;\n    let y: Field = 20; // Out of bounds\n\n    let commitment = compute_commitment(x, y, salt);\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n/// Cross-check test: verify hashes match what Solidity produces\n/// CRITICAL: If this test fails, circuit and contract are out of sync!\n#[test]\nfn test_cross_check_with_solidity() {\n    // Test values (same as our earlier Solidity verification)\n    let x: Field = 5;\n    let y: Field = 10;\n    let seed: Field = 12345;\n    \n    // Compute cell hash for treasure check\n    let cell_hash = hash_3([x, y, seed]);\n    \n    // This MUST match what Solidity's PoseidonT4.hash([5, 10, 12345]) returns:\n    // 0x18f86d5a25285414dde90acbf12c8878ccb98ac255c572800aec7c97745855c0\n    let expected_cell_hash: Field = 0x18f86d5a25285414dde90acbf12c8878ccb98ac255c572800aec7c97745855c0;\n    assert(cell_hash == expected_cell_hash, \"CRITICAL: Cell hash mismatch with Solidity!\");\n    \n    println(f\"Cross-check PASSED: poseidon(5, 10, 12345) = {cell_hash}\");\n}\n","path":"/root/clawd/projects/shadowchain/circuits/claim_artifact/src/main.nr"},"65":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"66":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"67":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert","directive_to_radix"]}