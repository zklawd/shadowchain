{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":5315016813190303422,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"treasure_seed","type":{"kind":"field"},"visibility":"public"},{"name":"artifact_id","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"287151366751320589":{"error_kind":"string","string":"Cell byte range check failed"},"1272965546042368918":{"error_kind":"string","string":"Artifact ID mismatch"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"9989860789624223510":{"error_kind":"string","string":"Cell is not a treasure"},"12212259287858967958":{"error_kind":"string","string":"Y coordinate out of bounds"},"13827481945052318821":{"error_kind":"string","string":"Position commitment mismatch"},"14171121810365326921":{"error_kind":"string","string":"X coordinate out of bounds"},"15187041237563348081":{"error_kind":"string","string":"Artifact hash decomposition failed"},"15224695934592041648":{"error_kind":"string","string":"Cell hash decomposition failed"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18427058232404860754":{"error_kind":"string","string":"Artifact byte range check failed"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"use std::hash::pedersen_hash;\nuse poseidon::poseidon::bn254::hash_3;\nuse poseidon::poseidon::bn254::hash_4;\n\n/// Threshold for treasure cells (same as contract: hash % 256 < 20 means ~7.8% of cells)\nglobal TREASURE_THRESHOLD: Field = 20;\n\n/// Domain separator for artifact ID derivation (must match contract!)\n/// \"artifact\" as ASCII: 0x617274696661637400\nglobal ARTIFACT_DOMAIN_SEP: Field = 0x617274696661637400;\n\n// ============================================================\n// Unconstrained helpers for witness generation\n// ============================================================\n\n/// Get the last byte of a field (f mod 256) and the quotient\nunconstrained fn decompose_mod_256(f: Field) -> (Field, Field) {\n    let bytes = f.to_be_bytes::<32>();\n    let last_byte = bytes[31] as Field;\n    let quotient = (f - last_byte) / 256;\n    (last_byte, quotient)\n}\n\n/// Claim Artifact Circuit (Optimized)\n/// Proves a player is at a valid procedurally-generated treasure cell.\n///\n/// Private inputs: x, y, salt\n/// Public inputs: commitment, treasure_seed, artifact_id\n///\n/// Proves:\n///   1. commitment = pedersen(x, y, salt)  -- player knows their position\n///   2. poseidon(x, y, treasure_seed) % 256 < THRESHOLD -- cell is a treasure\n///   3. artifact_id matches poseidon(x, y, treasure_seed, ARTIFACT_DOMAIN_SEP) derivation\nfn main(\n    // Private inputs\n    x: Field,\n    y: Field,\n    salt: Field,\n    // Public inputs\n    commitment: pub Field,\n    treasure_seed: pub Field,\n    artifact_id: pub Field,\n) {\n    // Validate coordinates are in bounds (0-15)\n    // Use Field comparison - avoid u8 cast range checks\n    assert(x as u8 < 16, \"X coordinate out of bounds\");\n    assert(y as u8 < 16, \"Y coordinate out of bounds\");\n\n    // 1. Verify position commitment (still using Pedersen for commitments)\n    let computed_commitment = pedersen_hash([x, y, salt]);\n    assert(computed_commitment == commitment, \"Position commitment mismatch\");\n\n    // 2. Verify cell is a procedural treasure using POSEIDON\n    //    poseidon(x, y, treasure_seed) % 256 < THRESHOLD\n    let cell_hash = hash_3([x, y, treasure_seed]);\n    \n    // Safety: decompose_mod_256 computes f mod 256 and quotient, verified below\n    let (cell_last_byte, cell_quotient) = unsafe { decompose_mod_256(cell_hash) };\n    // Verify decomposition: cell_hash == quotient * 256 + last_byte\n    assert(cell_hash == cell_quotient * 256 + cell_last_byte, \"Cell hash decomposition failed\");\n    // Verify last_byte < 256 (range check)\n    assert((cell_last_byte as u8) as Field == cell_last_byte, \"Cell byte range check failed\");\n    // Verify it's a treasure\n    assert(cell_last_byte as u8 < TREASURE_THRESHOLD as u8, \"Cell is not a treasure\");\n\n    // 3. Verify artifact_id matches derivation using POSEIDON\n    //    artifact_id = (poseidon(x, y, treasure_seed, ARTIFACT_DOMAIN_SEP) % 8) + 1\n    let artifact_hash = hash_4([x, y, treasure_seed, ARTIFACT_DOMAIN_SEP]);\n    \n    // Safety: decompose_mod_256 computes f mod 256, verified below  \n    let (artifact_last_byte, artifact_quotient) = unsafe { decompose_mod_256(artifact_hash) };\n    // Verify decomposition\n    assert(artifact_hash == artifact_quotient * 256 + artifact_last_byte, \"Artifact hash decomposition failed\");\n    // Verify last_byte < 256\n    assert((artifact_last_byte as u8) as Field == artifact_last_byte, \"Artifact byte range check failed\");\n    \n    // Compute derived_id = (last_byte % 8) + 1\n    // Since last_byte < 256, we need last_byte % 8\n    // We can verify: last_byte = q8 * 8 + r where r < 8 and r + 1 = artifact_id\n    let derived_remainder = artifact_last_byte as u8 % 8;\n    let derived_id = (derived_remainder + 1) as Field;\n    assert(artifact_id == derived_id, \"Artifact ID mismatch\");\n\n    // artifact_id is derived as (x % 8) + 1, which is always in [1,8]\n    // No need for additional range assertions\n}\n\n/// Helper: compute a position commitment (still uses Pedersen)\nfn compute_commitment(x: Field, y: Field, salt: Field) -> Field {\n    pedersen_hash([x, y, salt])\n}\n\n/// Helper: check if a cell is a treasure using Poseidon\nfn is_treasure(x: Field, y: Field, treasure_seed: Field) -> bool {\n    let cell_hash = hash_3([x, y, treasure_seed]);\n    let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n    let hash_mod = cell_hash_bytes[31] as u32;\n    hash_mod < TREASURE_THRESHOLD as u32\n}\n\n// ============================================================\n// Test helpers (unconstrained for efficiency)\n// ============================================================\n\n/// Find a treasure cell for testing using Poseidon\nunconstrained fn find_treasure_cell(treasure_seed: Field) -> (Field, Field) {\n    let mut result_x: Field = 0;\n    let mut result_y: Field = 0;\n    let mut found = false;\n    \n    for y in 0..16 {\n        for x in 0..16 {\n            if !found {\n                let cell_hash = poseidon::poseidon::bn254::hash_3([x as Field, y as Field, treasure_seed]);\n                let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n                let hash_mod = cell_hash_bytes[31] as u32;\n                if hash_mod < TREASURE_THRESHOLD as u32 {\n                    result_x = x as Field;\n                    result_y = y as Field;\n                    found = true;\n                }\n            }\n        }\n    }\n    (result_x, result_y)\n}\n\n/// Find a non-treasure cell for testing\nunconstrained fn find_non_treasure_cell(treasure_seed: Field) -> (Field, Field) {\n    let mut result_x: Field = 0;\n    let mut result_y: Field = 0;\n    let mut found = false;\n    \n    for y in 0..16 {\n        for x in 0..16 {\n            if !found {\n                let cell_hash = poseidon::poseidon::bn254::hash_3([x as Field, y as Field, treasure_seed]);\n                let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n                let hash_mod = cell_hash_bytes[31] as u32;\n                if hash_mod >= TREASURE_THRESHOLD as u32 {\n                    result_x = x as Field;\n                    result_y = y as Field;\n                    found = true;\n                }\n            }\n        }\n    }\n    (result_x, result_y)\n}\n\n/// Get artifact ID (unconstrained version)\nunconstrained fn get_artifact_id_unconstrained(x: Field, y: Field, treasure_seed: Field) -> u32 {\n    let artifact_hash = poseidon::poseidon::bn254::hash_4([x, y, treasure_seed, ARTIFACT_DOMAIN_SEP]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    ((artifact_bytes[31] as u32) % 8) + 1\n}\n\n// ============================================================\n// Tests\n// ============================================================\n\n#[test]\nfn test_valid_claim() {\n    let treasure_seed: Field = 12345;\n    \n    // Safety: test-only unconstrained helper to find treasure\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n\n    let commitment = compute_commitment(x, y, salt);\n    // Safety: test-only unconstrained helper\n    let artifact_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) } as Field;\n\n    main(x, y, salt, commitment, treasure_seed, artifact_id);\n}\n\n#[test]\nfn test_different_seeds_different_treasures() {\n    let seed1: Field = 11111;\n    let seed2: Field = 22222;\n    \n    // Safety: test-only unconstrained helpers\n    let (x1, y1) = unsafe { find_treasure_cell(seed1) };\n    // Safety: test-only unconstrained helpers\n    let (x2, y2) = unsafe { find_treasure_cell(seed2) };\n    \n    // Just verify both are valid treasures\n    assert(is_treasure(x1, y1, seed1));\n    assert(is_treasure(x2, y2, seed2));\n}\n\n#[test(should_fail_with = \"Cell is not a treasure\")]\nfn test_non_treasure_cell_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    \n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_non_treasure_cell(treasure_seed) };\n\n    let commitment = compute_commitment(x, y, salt);\n    // Try to claim artifact 1 at non-treasure cell\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let treasure_seed: Field = 12345;\n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n    // Safety: test-only unconstrained helper\n    let artifact_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) } as Field;\n\n    // Wrong commitment - should fail\n    main(x, y, salt, 0, treasure_seed, artifact_id);\n}\n\n#[test(should_fail)]\nfn test_wrong_artifact_id_fails() {\n    let treasure_seed: Field = 12345;\n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n\n    let commitment = compute_commitment(x, y, salt);\n    // Safety: test-only unconstrained helper\n    let correct_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) };\n    // Pick wrong ID\n    let wrong_id = if correct_id == 1 { 2 } else { 1 };\n\n    main(x, y, salt, commitment, treasure_seed, wrong_id as Field);\n}\n\n#[test(should_fail_with = \"X coordinate out of bounds\")]\nfn test_x_out_of_bounds_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    let x: Field = 16; // Out of bounds\n    let y: Field = 5;\n\n    let commitment = compute_commitment(x, y, salt);\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n#[test(should_fail_with = \"Y coordinate out of bounds\")]\nfn test_y_out_of_bounds_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    let x: Field = 5;\n    let y: Field = 20; // Out of bounds\n\n    let commitment = compute_commitment(x, y, salt);\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n/// Cross-check test: verify hashes match what Solidity produces\n/// CRITICAL: If this test fails, circuit and contract are out of sync!\n#[test]\nfn test_cross_check_with_solidity() {\n    // Test values (same as our earlier Solidity verification)\n    let x: Field = 5;\n    let y: Field = 10;\n    let seed: Field = 12345;\n    \n    // Compute cell hash for treasure check\n    let cell_hash = hash_3([x, y, seed]);\n    \n    // This MUST match what Solidity's PoseidonT4.hash([5, 10, 12345]) returns:\n    // 0x18f86d5a25285414dde90acbf12c8878ccb98ac255c572800aec7c97745855c0\n    let expected_cell_hash: Field = 0x18f86d5a25285414dde90acbf12c8878ccb98ac255c572800aec7c97745855c0;\n    assert(cell_hash == expected_cell_hash, \"CRITICAL: Cell hash mismatch with Solidity!\");\n    \n    println(f\"Cross-check PASSED: poseidon(5, 10, 12345) = {cell_hash}\");\n}\n\n#[test]\nfn verify_live_sepolia_treasure() {\n    // Values from live Sepolia test on v3 contract\n    let x: Field = 14;\n    let y: Field = 1;\n    let seed: Field = 0x223962be0387466c5cd4618d4e51f423eeafded9a89df52ec1128b4c2b566a0e;\n    \n    // Check if it's a treasure (hash mod 256 < 20)\n    let cell_hash = hash_3([x, y, seed]);\n    let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n    let hash_mod = cell_hash_bytes[31] as u32;\n    \n    println(f\"poseidon(14, 1, seed) last byte = {hash_mod}\");\n    assert(hash_mod < TREASURE_THRESHOLD as u32, \"Circuit says NOT a treasure!\");\n    println(f\"Circuit confirms: (14, 1) IS a treasure!\");\n    \n    // Check artifact ID (contract returned 3)\n    let artifact_hash = hash_4([x, y, seed, ARTIFACT_DOMAIN_SEP]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    let artifact_id = ((artifact_bytes[31] as u32) % 8) + 1;\n    \n    println(f\"Circuit artifact ID = {artifact_id}\");\n    assert(artifact_id == 3, \"Artifact ID mismatch with contract!\");\n    println(f\"VERIFIED: Circuit and contract agree - artifact ID = 3\");\n}\n","path":"/root/clawd/projects/shadowchain/circuits/claim_artifact/src/main.nr"},"65":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"66":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"67":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"names":["main"],"brillig_names":["decompose_hint","decompose_mod_256","directive_integer_quotient","directive_invert"]}