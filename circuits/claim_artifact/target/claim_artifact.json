{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":10618859059563066538,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"treasure_seed","type":{"kind":"field"},"visibility":"public"},{"name":"artifact_id","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"1272965546042368918":{"error_kind":"string","string":"Artifact ID mismatch"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6186021530770169760":{"error_kind":"string","string":"Artifact ID out of range"},"6633934283979419638":{"error_kind":"string","string":"Invalid artifact ID"},"9989860789624223510":{"error_kind":"string","string":"Cell is not a treasure"},"12212259287858967958":{"error_kind":"string","string":"Y coordinate out of bounds"},"13827481945052318821":{"error_kind":"string","string":"Position commitment mismatch"},"14171121810365326921":{"error_kind":"string","string":"X coordinate out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"use std::hash::pedersen_hash;\n\n/// Threshold for treasure cells (same as contract: hash % 256 < 20 means ~7.8% of cells)\nglobal TREASURE_THRESHOLD: u32 = 20;\n\n/// Claim Artifact Circuit (Procedural Treasures)\n/// Proves a player is at a valid procedurally-generated treasure cell.\n///\n/// Private inputs: x, y, salt\n/// Public inputs: commitment, treasure_seed, artifact_id\n///\n/// Proves:\n///   1. commitment = hash(x, y, salt)  -- player knows their position\n///   2. hash(x, y, treasure_seed) % 256 < THRESHOLD -- cell is a treasure\n///   3. artifact_id matches derivation from (x, y, treasure_seed)\nfn main(\n    // Private inputs\n    x: Field,\n    y: Field,\n    salt: Field,\n    // Public inputs\n    commitment: pub Field,\n    treasure_seed: pub Field,\n    artifact_id: pub Field,\n) {\n    // Validate coordinates are in bounds (0-15)\n    let x_u8 = x as u8;\n    let y_u8 = y as u8;\n    assert(x_u8 < 16, \"X coordinate out of bounds\");\n    assert(y_u8 < 16, \"Y coordinate out of bounds\");\n\n    // 1. Verify position commitment\n    let computed_commitment = pedersen_hash([x, y, salt]);\n    assert(computed_commitment == commitment, \"Position commitment mismatch\");\n\n    // 2. Verify cell is a procedural treasure\n    //    hash(x, y, treasure_seed) % 256 < THRESHOLD\n    let cell_hash = pedersen_hash([x, y, treasure_seed]);\n    let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n    // Use last byte for modulo 256\n    let hash_mod = cell_hash_bytes[31] as u32;\n    assert(hash_mod < TREASURE_THRESHOLD, \"Cell is not a treasure\");\n\n    // 3. Verify artifact_id matches derivation\n    //    artifact_id = (hash(x, y, treasure_seed, \"artifact\") % 8) + 1\n    let artifact_hash = pedersen_hash([x, y, treasure_seed, 0x617274696661637400]); // \"artifact\\0\" as field\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    let derived_id = ((artifact_bytes[31] as u32) % 8) + 1;\n    assert(artifact_id as u32 == derived_id, \"Artifact ID mismatch\");\n\n    // Validate artifact_id is in valid range\n    let aid = artifact_id as u32;\n    assert(aid >= 1, \"Invalid artifact ID\");\n    assert(aid <= 8, \"Artifact ID out of range\");\n}\n\n/// Helper: compute a position commitment\nfn compute_commitment(x: Field, y: Field, salt: Field) -> Field {\n    pedersen_hash([x, y, salt])\n}\n\n/// Helper: check if a cell is a treasure\nfn is_treasure(x: Field, y: Field, treasure_seed: Field) -> bool {\n    let cell_hash = pedersen_hash([x, y, treasure_seed]);\n    let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n    let hash_mod = cell_hash_bytes[31] as u32;\n    hash_mod < TREASURE_THRESHOLD\n}\n\n/// Helper: compute artifact ID at a treasure cell\nfn get_artifact_id(x: Field, y: Field, treasure_seed: Field) -> u32 {\n    let artifact_hash = pedersen_hash([x, y, treasure_seed, 0x617274696661637400]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    ((artifact_bytes[31] as u32) % 8) + 1\n}\n\n// ============================================================\n// Test helpers (unconstrained for efficiency)\n// ============================================================\n\n/// Find a treasure cell for testing\nunconstrained fn find_treasure_cell(treasure_seed: Field) -> (Field, Field) {\n    let mut result_x: Field = 0;\n    let mut result_y: Field = 0;\n    let mut found = false;\n    \n    for y in 0..16 {\n        for x in 0..16 {\n            if !found {\n                let cell_hash = std::hash::pedersen_hash([x as Field, y as Field, treasure_seed]);\n                let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n                let hash_mod = cell_hash_bytes[31] as u32;\n                if hash_mod < TREASURE_THRESHOLD {\n                    result_x = x as Field;\n                    result_y = y as Field;\n                    found = true;\n                }\n            }\n        }\n    }\n    (result_x, result_y)\n}\n\n/// Find a non-treasure cell for testing\nunconstrained fn find_non_treasure_cell(treasure_seed: Field) -> (Field, Field) {\n    let mut result_x: Field = 0;\n    let mut result_y: Field = 0;\n    let mut found = false;\n    \n    for y in 0..16 {\n        for x in 0..16 {\n            if !found {\n                let cell_hash = std::hash::pedersen_hash([x as Field, y as Field, treasure_seed]);\n                let cell_hash_bytes = cell_hash.to_be_bytes::<32>();\n                let hash_mod = cell_hash_bytes[31] as u32;\n                if hash_mod >= TREASURE_THRESHOLD {\n                    result_x = x as Field;\n                    result_y = y as Field;\n                    found = true;\n                }\n            }\n        }\n    }\n    (result_x, result_y)\n}\n\n/// Get artifact ID (unconstrained version)\nunconstrained fn get_artifact_id_unconstrained(x: Field, y: Field, treasure_seed: Field) -> u32 {\n    let artifact_hash = std::hash::pedersen_hash([x, y, treasure_seed, 0x617274696661637400]);\n    let artifact_bytes = artifact_hash.to_be_bytes::<32>();\n    ((artifact_bytes[31] as u32) % 8) + 1\n}\n\n// ============================================================\n// Tests\n// ============================================================\n\n#[test]\nfn test_valid_claim() {\n    let treasure_seed: Field = 12345;\n    \n    // Safety: test-only unconstrained helper to find treasure\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n\n    let commitment = compute_commitment(x, y, salt);\n    // Safety: test-only unconstrained helper\n    let artifact_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) } as Field;\n\n    main(x, y, salt, commitment, treasure_seed, artifact_id);\n}\n\n#[test]\nfn test_different_seeds_different_treasures() {\n    let seed1: Field = 11111;\n    let seed2: Field = 22222;\n    \n    // Safety: test-only unconstrained helpers\n    let (x1, y1) = unsafe { find_treasure_cell(seed1) };\n    // Safety: test-only unconstrained helpers\n    let (x2, y2) = unsafe { find_treasure_cell(seed2) };\n    \n    // Just verify both are valid treasures\n    assert(is_treasure(x1, y1, seed1));\n    assert(is_treasure(x2, y2, seed2));\n}\n\n#[test(should_fail_with = \"Cell is not a treasure\")]\nfn test_non_treasure_cell_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    \n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_non_treasure_cell(treasure_seed) };\n\n    let commitment = compute_commitment(x, y, salt);\n    // Try to claim artifact 1 at non-treasure cell\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n#[test(should_fail)]\nfn test_wrong_commitment_fails() {\n    let treasure_seed: Field = 12345;\n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n    // Safety: test-only unconstrained helper\n    let artifact_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) } as Field;\n\n    // Wrong commitment - should fail\n    main(x, y, salt, 0, treasure_seed, artifact_id);\n}\n\n#[test(should_fail)]\nfn test_wrong_artifact_id_fails() {\n    let treasure_seed: Field = 12345;\n    // Safety: test-only unconstrained helper\n    let (x, y) = unsafe { find_treasure_cell(treasure_seed) };\n    let salt: Field = 42;\n\n    let commitment = compute_commitment(x, y, salt);\n    // Safety: test-only unconstrained helper\n    let correct_id = unsafe { get_artifact_id_unconstrained(x, y, treasure_seed) };\n    // Pick wrong ID\n    let wrong_id = if correct_id == 1 { 2 } else { 1 };\n\n    main(x, y, salt, commitment, treasure_seed, wrong_id as Field);\n}\n\n#[test(should_fail_with = \"X coordinate out of bounds\")]\nfn test_x_out_of_bounds_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    let x: Field = 16; // Out of bounds\n    let y: Field = 5;\n\n    let commitment = compute_commitment(x, y, salt);\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n\n#[test(should_fail_with = \"Y coordinate out of bounds\")]\nfn test_y_out_of_bounds_fails() {\n    let treasure_seed: Field = 12345;\n    let salt: Field = 42;\n    let x: Field = 5;\n    let y: Field = 20; // Out of bounds\n\n    let commitment = compute_commitment(x, y, salt);\n    main(x, y, salt, commitment, treasure_seed, 1);\n}\n","path":"/root/clawd/projects/shadowchain/circuits/claim_artifact/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert","directive_to_radix"]}