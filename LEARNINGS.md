# ShadowChain Build Learnings üßµ

*Things I learned building a ZK fog-of-war game on Ethereum. Thread material.*

---

## 1. Noir Circuit Development

### `unconstrained` functions are your friend for tests
Noir's constrained execution means no early returns or breaks. For test helpers that search for values, use `unconstrained fn` and call with `unsafe {}` blocks. Just add `// Safety:` comments.

### Assertion order is non-deterministic in ZK circuits
When multiple assertions fail, Noir doesn't guarantee which error message you'll see. Use `#[test(should_fail)]` without specific messages for robustness.

### `assembly ("memory-safe")` is required for complex verifiers
Solidity verifiers generated by `bb` (Barretenberg) need memory-safe annotations on all assembly blocks when using `via_ir = true`. Quick fix:
```bash
sed -i 's/assembly {/assembly ("memory-safe") {/g' verifier.sol
```

---

## 2. ZK Game Design Patterns

### Multi-party commitment for fair procedural generation
Problem: If treasure locations are deterministic from game seed, players can precompute them before joining.

Solution: `treasureSeed = hash(gameSeed, player1Commit, player2Commit, ...)`
Treasures only become determinable after ALL players commit their positions. Nobody can front-run.

### Circuit-contract hash function mismatch is fine
Circuits use Pedersen (efficient in ZK), contracts use keccak256 (cheap on EVM). For treasure verification:
- Circuit is authoritative (proves player is at valid treasure)
- Contract's `isTreasure()` view function is for UI convenience
- They might disagree slightly ‚Äî that's okay, proofs are what matter

### Position commitments hide AND bind
`commitment = hash(x, y, salt)` achieves two properties:
1. **Hiding**: Nobody can learn (x,y) from commitment
2. **Binding**: Player can't change position after committing

The salt prevents rainbow table attacks on the 16√ó16 grid.

---

## 3. Solidity Patterns

### Stack too deep? `via_ir = true`
The Yul IR pipeline handles deep stacks better than legacy codegen. Essential for complex verifier contracts. Add to `foundry.toml`:
```toml
via_ir = true
optimizer = true
```

### Procedural generation on-chain is cheap
```solidity
function isTreasure(uint8 x, uint8 y, bytes32 seed) view returns (bool) {
    return uint256(keccak256(abi.encodePacked(x, y, seed))) % 256 < 20;
}
```
One keccak256 = ~30 gas. Way cheaper than storing a bitmap.

### Store commitments in a mapping array pattern
```solidity
mapping(uint256 => bytes32[]) public gameCommitments;
```
Allows iterating over all commitments when computing derived seeds.

---

## 4. Testing ZK Games

### Fuzz testing map generation is crucial
```solidity
function testFuzz_spawnPointsAlwaysPassable(uint256 seed) public {
    // Spawn points must never be walls
}
```
Found edge cases where procedural walls blocked spawns.

### Mock verifiers for fast iteration
Real ZK verification is slow. Use mock verifiers that always return true during contract development:
```solidity
contract MockVerifier {
    function verify(bytes calldata, bytes32[] calldata) external pure returns (bool) {
        return true;
    }
}
```

---

## 5. Noir-Specific Gotchas

### Field to bytes conversion for modulo
```noir
let hash = pedersen_hash([x, y, seed]);
let hash_bytes = hash.to_be_bytes::<32>();
let mod_256 = hash_bytes[31] as u32; // Last byte = hash % 256
```

### No string literals for domain separation
```noir
// Won't work: pedersen_hash([x, y, "artifact"])
// Use hex-encoded ASCII:
pedersen_hash([x, y, seed, 0x617274696661637400]) // "artifact\0"
```

### Coordinate validation must be explicit
```noir
let x_u8 = x as u8;
assert(x_u8 < 16, "X out of bounds");
```
Field elements are huge ‚Äî always validate ranges.

### Unconstrained helpers need `unsafe {}` blocks
```noir
// Safety: test-only unconstrained helper
let (x, y) = unsafe { find_treasure_cell(seed) };
```
Noir 1.0+ requires explicit `unsafe` for calling unconstrained functions from constrained context. Add `// Safety:` comments to silence warnings.

---

## 6. Gas Optimization

### Pack structs carefully
```solidity
struct Player {
    int16 hp;        // 2 bytes
    int8 attack;     // 1 byte
    int8 defense;    // 1 byte
    uint8 status;    // 1 byte
    // 5 bytes ‚Üí fits in 1 slot with commitment
    bytes32 commitment;
}
```

### Bitmap > mapping for small fixed sets
16√ó16 grid = 256 cells = 1 uint256 bitmap for walls/treasures.

---

## 7. Architecture Decisions

### Why ZK for fog-of-war?
- **Trustless**: No server needed to hide positions
- **Verifiable**: All moves proven valid without revealing location
- **Fair**: Can't lie about combat outcomes

### Why Pedersen over Poseidon?
Barretenberg's Pedersen is battle-tested and native to Noir stdlib. Poseidon is faster but less mature tooling.

### Why commit-reveal over encrypted state?
Simpler UX. Players just need to remember their salt, not manage encryption keys.

---

*More learnings coming as we build toward mainnet... üõ°Ô∏è*
