{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":9186742738642355807,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"player_salt","type":{"kind":"field"},"visibility":"private"},{"name":"artifact_ids","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"owned_artifacts","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"inventory_salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"stats_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"game_id","type":{"kind":"field"},"visibility":"public"},{"name":"inventory_commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6633934283979419638":{"error_kind":"string","string":"Invalid artifact ID"},"8359277020837411998":{"error_kind":"string","string":"Inventory commitment mismatch"},"8642275523034746091":{"error_kind":"string","string":"Stats commitment mismatch"},"8663955338551638008":{"error_kind":"string","string":"Duplicate artifact in claimed set"},"12212259287858967958":{"error_kind":"string","string":"Y coordinate out of bounds"},"13827481945052318821":{"error_kind":"string","string":"Position commitment mismatch"},"14171121810365326921":{"error_kind":"string","string":"X coordinate out of bounds"},"17451869598115142554":{"error_kind":"string","string":"Invalid game ID"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18217600251842358550":{"error_kind":"string","string":"Claimed artifact not in inventory"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"use std::hash::pedersen_hash;\n\n/// Maximum number of artifacts a player can hold\nglobal MAX_ARTIFACTS: u32 = 8;\n\n/// Base stats for all players\nglobal BASE_HP: u32 = 100;\nglobal BASE_ATTACK: u32 = 10;\nglobal BASE_DEFENSE: u32 = 5;\n\n/// Grid size for bounds checking\nglobal GRID_SIZE: u8 = 16;\n\n/// Artifact stat bonuses as lookup tables (indexed by artifact_id 0-8)\n/// Format: [hp_bonus, atk_bonus, def_bonus, hp_penalty, atk_penalty, def_penalty]\n///\n/// Matches ArtifactRegistry.sol definitions:\n///   ID 0: Empty slot      -> all zeros\n///   ID 1: Shadow Blade    -> ATK +5\n///   ID 2: Iron Aegis      -> DEF +5\n///   ID 3: Vitality Amulet -> HP +20\n///   ID 4: Berserker Helm  -> ATK +8, DEF -2\n///   ID 5: Phantom Cloak   -> ATK -1, DEF +7, HP +10\n///   ID 6: War Gauntlets   -> ATK +3, DEF +3\n///   ID 7: Blood Crystal   -> ATK +6, HP -10\n///   ID 8: Soul Vessel     -> ATK +2, DEF +2, HP +15\n\n// HP bonuses by artifact ID (0-8)\nglobal HP_BONUS: [u32; 9] = [0, 0, 0, 20, 0, 10, 0, 0, 15];\n// ATK bonuses by artifact ID\nglobal ATK_BONUS: [u32; 9] = [0, 5, 0, 0, 8, 0, 3, 6, 2];\n// DEF bonuses by artifact ID\nglobal DEF_BONUS: [u32; 9] = [0, 0, 5, 0, 0, 7, 3, 0, 2];\n// HP penalties by artifact ID\nglobal HP_PENALTY: [u32; 9] = [0, 0, 0, 0, 0, 0, 0, 10, 0];\n// ATK penalties by artifact ID\nglobal ATK_PENALTY: [u32; 9] = [0, 0, 0, 0, 0, 1, 0, 0, 0];\n// DEF penalties by artifact ID\nglobal DEF_PENALTY: [u32; 9] = [0, 0, 0, 0, 2, 0, 0, 0, 0];\n\n/// Combat Reveal Circuit (SECURED with ownership verification + uniqueness)\n/// Proves player stats (HP, attack, defense) are correctly derived from\n/// base stats + collected artifacts.\n///\n/// SECURITY FEATURES:\n///   - Position bounds checking (x, y in 0-15)\n///   - Artifact ownership verification via inventory commitment\n///   - Artifact uniqueness check (no duplicates in claimed set)\n///\n/// Private inputs: x, y, salt, player_salt, artifact_ids[8], owned_artifacts[8], inventory_salt\n/// Public inputs: commitment, stats_commitment, game_id, inventory_commitment\n///\n/// Proves:\n///   1. commitment = hash(x, y, salt)\n///   2. Position is within bounds (0-15)\n///   3. inventory_commitment matches hash of owned_artifacts + inventory_salt\n///   4. All claimed artifact_ids are either 0 (empty) or exist in owned_artifacts\n///   5. No duplicate non-zero artifact_ids in the claimed set\n///   6. Stats are correctly computed from base + artifact bonuses - penalties\n///   7. stats_commitment = hash(hp, attack, defense, player_salt)\n///   8. Stats are floored: HP >= 1, ATK >= 1, DEF >= 0\nfn main(\n    // Private inputs\n    x: Field,\n    y: Field,\n    salt: Field,\n    player_salt: Field,\n    artifact_ids: [u32; MAX_ARTIFACTS],      // Artifacts claimed for THIS combat\n    owned_artifacts: [u32; MAX_ARTIFACTS],   // NEW: Player's full inventory\n    inventory_salt: Field,                    // NEW: Salt for inventory commitment\n    // Public inputs\n    commitment: pub Field,\n    stats_commitment: pub Field,\n    game_id: pub Field,\n    inventory_commitment: pub Field,          // NEW: Commitment to player's inventory\n) {\n    // 1. Verify position commitment\n    let computed_commitment = pedersen_hash([x, y, salt]);\n    assert(computed_commitment == commitment, \"Position commitment mismatch\");\n\n    // 2. NEW: Position bounds check (defense-in-depth)\n    let x_u8 = x as u8;\n    let y_u8 = y as u8;\n    assert(x_u8 < GRID_SIZE, \"X coordinate out of bounds\");\n    assert(y_u8 < GRID_SIZE, \"Y coordinate out of bounds\");\n\n    // 3. NEW: Verify inventory commitment\n    //    This proves the player actually owns the artifacts they're claiming\n    let computed_inventory = pedersen_hash([\n        owned_artifacts[0] as Field,\n        owned_artifacts[1] as Field,\n        owned_artifacts[2] as Field,\n        owned_artifacts[3] as Field,\n        owned_artifacts[4] as Field,\n        owned_artifacts[5] as Field,\n        owned_artifacts[6] as Field,\n        owned_artifacts[7] as Field,\n        inventory_salt,\n    ]);\n    assert(computed_inventory == inventory_commitment, \"Inventory commitment mismatch\");\n\n    // 4. NEW: Verify each claimed artifact exists in owned_artifacts\n    //    Empty slots (0) are always allowed\n    for i in 0..MAX_ARTIFACTS {\n        let claimed = artifact_ids[i];\n        if claimed != 0 {\n            // Must find this artifact in owned_artifacts\n            let mut found = false;\n            for j in 0..MAX_ARTIFACTS {\n                if owned_artifacts[j] == claimed {\n                    found = true;\n                }\n            }\n            assert(found, \"Claimed artifact not in inventory\");\n        }\n    }\n\n    // 5. NEW: Verify no duplicate non-zero artifact_ids\n    //    This prevents stacking the same artifact multiple times\n    for i in 0..MAX_ARTIFACTS {\n        for j in (i + 1)..MAX_ARTIFACTS {\n            let aid_i = artifact_ids[i];\n            let aid_j = artifact_ids[j];\n            // If both are non-zero, they must be different\n            if (aid_i != 0) & (aid_j != 0) {\n                assert(aid_i != aid_j, \"Duplicate artifact in claimed set\");\n            }\n        }\n    }\n\n    // 6. Compute stats from base + artifacts using lookup tables\n    let mut hp_bonus: u32 = 0;\n    let mut atk_bonus: u32 = 0;\n    let mut def_bonus: u32 = 0;\n    let mut hp_penalty: u32 = 0;\n    let mut atk_penalty: u32 = 0;\n    let mut def_penalty: u32 = 0;\n\n    for i in 0..MAX_ARTIFACTS {\n        let aid = artifact_ids[i];\n        // Artifact IDs must be valid (0-8)\n        assert(aid <= 8, \"Invalid artifact ID\");\n\n        // Use lookup tables instead of if-else chain\n        hp_bonus += HP_BONUS[aid];\n        atk_bonus += ATK_BONUS[aid];\n        def_bonus += DEF_BONUS[aid];\n        hp_penalty += HP_PENALTY[aid];\n        atk_penalty += ATK_PENALTY[aid];\n        def_penalty += DEF_PENALTY[aid];\n    }\n\n    // Apply bonuses then penalties with floor values matching the contract:\n    //   HP >= 1, ATK >= 1, DEF >= 0\n    let raw_hp = BASE_HP + hp_bonus;\n    let hp = if raw_hp > hp_penalty {\n        let result = raw_hp - hp_penalty;\n        if result < 1 { 1 } else { result }\n    } else {\n        1\n    };\n\n    let raw_attack = BASE_ATTACK + atk_bonus;\n    let attack = if raw_attack > atk_penalty {\n        let result = raw_attack - atk_penalty;\n        if result < 1 { 1 } else { result }\n    } else {\n        1\n    };\n\n    let raw_defense = BASE_DEFENSE + def_bonus;\n    let defense = if raw_defense >= def_penalty {\n        raw_defense - def_penalty\n    } else {\n        0\n    };\n\n    // 7. Verify stats commitment\n    let computed_stats = pedersen_hash([\n        hp as Field,\n        attack as Field,\n        defense as Field,\n        player_salt,\n    ]);\n    assert(computed_stats == stats_commitment, \"Stats commitment mismatch\");\n\n    // game_id is included as a public input to bind the proof to a specific game.\n    // Prevent replay across games.\n    assert(game_id != 0, \"Invalid game ID\");\n}\n\n/// Helper: compute position commitment\nfn compute_commitment(x: Field, y: Field, salt: Field) -> Field {\n    pedersen_hash([x, y, salt])\n}\n\n/// Helper: compute stats commitment\nfn compute_stats_commitment(hp: u32, attack: u32, defense: u32, player_salt: Field) -> Field {\n    pedersen_hash([hp as Field, attack as Field, defense as Field, player_salt])\n}\n\n/// Helper: compute inventory commitment\nfn compute_inventory_commitment(owned: [u32; MAX_ARTIFACTS], salt: Field) -> Field {\n    pedersen_hash([\n        owned[0] as Field,\n        owned[1] as Field,\n        owned[2] as Field,\n        owned[3] as Field,\n        owned[4] as Field,\n        owned[5] as Field,\n        owned[6] as Field,\n        owned[7] as Field,\n        salt,\n    ])\n}\n\n// =========================================================================\n//                              TESTS\n// =========================================================================\n\n#[test]\nfn test_no_artifacts() {\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    let artifacts: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test]\nfn test_one_artifact_shadow_blade() {\n    // Shadow Blade (ID 1): +5 ATK -> HP=100, ATK=15, DEF=5\n    let x: Field = 3;\n    let y: Field = 7;\n    let salt: Field = 222;\n    let player_salt: Field = 888;\n    let inventory_salt: Field = 444;\n    let game_id: Field = 42;\n    \n    // Player owns and claims shadow blade\n    let artifacts: [u32; MAX_ARTIFACTS] = [1, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [1, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 15, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test]\nfn test_claim_subset_of_owned() {\n    // Player owns [1, 2, 3] but only claims [1, 3] for combat\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 222;\n    let inventory_salt: Field = 333;\n    let game_id: Field = 1;\n    \n    let owned: [u32; MAX_ARTIFACTS] = [1, 2, 3, 0, 0, 0, 0, 0];\n    let claimed: [u32; MAX_ARTIFACTS] = [1, 3, 0, 0, 0, 0, 0, 0];\n    \n    // Stats with just [1, 3]: Shadow Blade + Vitality Amulet\n    // HP: 100 + 0 + 20 = 120, ATK: 10 + 5 + 0 = 15, DEF: 5 + 0 + 0 = 5\n    \n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(120, 15, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n    \n    main(x, y, salt, player_salt, claimed, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test]\nfn test_all_eight_artifacts() {\n    // All artifacts: IDs 1-8\n    // HP: 100 + 45 - 10 = 135, ATK: 10 + 24 - 1 = 33, DEF: 5 + 17 - 2 = 20\n    let x: Field = 0;\n    let y: Field = 0;\n    let salt: Field = 999;\n    let player_salt: Field = 111;\n    let inventory_salt: Field = 777;\n    let game_id: Field = 99;\n    \n    let artifacts: [u32; MAX_ARTIFACTS] = [1, 2, 3, 4, 5, 6, 7, 8];\n    let owned: [u32; MAX_ARTIFACTS] = [1, 2, 3, 4, 5, 6, 7, 8];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(135, 33, 20, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Claimed artifact not in inventory\")]\nfn test_fake_artifact_fails() {\n    // Player owns nothing but claims Shadow Blade\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    let owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let claimed: [u32; MAX_ARTIFACTS] = [1, 0, 0, 0, 0, 0, 0, 0]; // Fake!\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 15, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, claimed, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Claimed artifact not in inventory\")]\nfn test_artifact_not_owned_fails() {\n    // Player owns [1, 2] but claims [1, 2, 3] - doesn't own 3\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 222;\n    let inventory_salt: Field = 333;\n    let game_id: Field = 1;\n    \n    let owned: [u32; MAX_ARTIFACTS] = [1, 2, 0, 0, 0, 0, 0, 0];\n    let claimed: [u32; MAX_ARTIFACTS] = [1, 2, 3, 0, 0, 0, 0, 0]; // 3 not owned!\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(120, 15, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, claimed, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Duplicate artifact in claimed set\")]\nfn test_duplicate_artifacts_fails() {\n    // Player owns [1, 2] but tries to claim [1, 1] - duplicate!\n    let x: Field = 0;\n    let y: Field = 0;\n    let salt: Field = 444;\n    let player_salt: Field = 666;\n    let inventory_salt: Field = 888;\n    let game_id: Field = 3;\n    \n    let owned: [u32; MAX_ARTIFACTS] = [1, 2, 0, 0, 0, 0, 0, 0];\n    let claimed: [u32; MAX_ARTIFACTS] = [1, 1, 0, 0, 0, 0, 0, 0]; // Duplicate!\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 20, 5, player_salt); // Would be wrong anyway\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, claimed, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"X coordinate out of bounds\")]\nfn test_x_out_of_bounds_fails() {\n    let x: Field = 16; // Out of bounds!\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    let artifacts: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Y coordinate out of bounds\")]\nfn test_y_out_of_bounds_fails() {\n    let x: Field = 5;\n    let y: Field = 20; // Out of bounds!\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    let artifacts: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Inventory commitment mismatch\")]\nfn test_fake_inventory_commitment_fails() {\n    // Player tries to fake their inventory\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    // Real inventory (empty) and claimed (empty)\n    let artifacts: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let real_owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    \n    // But provide fake inventory commitment claiming ownership of [1,2,3,4,5,6,7,8]\n    let fake_owned: [u32; MAX_ARTIFACTS] = [1, 2, 3, 4, 5, 6, 7, 8];\n    let fake_inventory_commitment = compute_inventory_commitment(fake_owned, inventory_salt);\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n\n    // Circuit will verify owned_artifacts matches inventory_commitment - should fail\n    main(x, y, salt, player_salt, artifacts, real_owned, inventory_salt, commitment, stats_commitment, game_id, fake_inventory_commitment);\n}\n\n#[test(should_fail_with = \"Stats commitment mismatch\")]\nfn test_wrong_stats_fails() {\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    // Has Shadow Blade (+5 ATK) but claims base stats\n    let artifacts: [u32; MAX_ARTIFACTS] = [1, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [1, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let wrong_stats = compute_stats_commitment(100, 10, 5, player_salt); // Should be ATK=15\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, wrong_stats, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Position commitment mismatch\")]\nfn test_wrong_position_fails() {\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    let artifacts: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(5, 5, 111, player_salt, artifacts, owned, inventory_salt, 0, stats_commitment, game_id, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Invalid game ID\")]\nfn test_zero_game_id_fails() {\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    \n    let artifacts: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [0, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, 0, inventory_commitment);\n}\n\n#[test(should_fail_with = \"Invalid artifact ID\")]\nfn test_invalid_artifact_id_fails() {\n    let x: Field = 5;\n    let y: Field = 5;\n    let salt: Field = 111;\n    let player_salt: Field = 999;\n    let inventory_salt: Field = 555;\n    let game_id: Field = 1;\n    \n    // Invalid artifact ID 99\n    let artifacts: [u32; MAX_ARTIFACTS] = [99, 0, 0, 0, 0, 0, 0, 0];\n    let owned: [u32; MAX_ARTIFACTS] = [99, 0, 0, 0, 0, 0, 0, 0];\n\n    let commitment = compute_commitment(x, y, salt);\n    let stats_commitment = compute_stats_commitment(100, 10, 5, player_salt);\n    let inventory_commitment = compute_inventory_commitment(owned, inventory_salt);\n\n    main(x, y, salt, player_salt, artifacts, owned, inventory_salt, commitment, stats_commitment, game_id, inventory_commitment);\n}\n","path":"/root/clawd/projects/shadowchain/circuits/combat_reveal/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}